/* eslint-disable @typescript-eslint/unbound-method */
import fs from 'fs'
import ts from 'typescript'
import sv2tsx from 'svelte2tsx'
import iti from 'itiriri'
import { relativePath ,relPathJson ,tsCompilerConfig ,tsConfigDir ,tsConfigFilePath } from './utils'

interface TsxMappingBase {
  sourcePath: string
  autoGenerated?: boolean
  code?: string
  virtualSourcePath?: string
}
interface TsxMappingVirtual {
  code: string
  virtualSourcePath: string
}
type TsxMapping = TsxMappingBase | (TsxMappingBase & TsxMappingVirtual)

function generateTsx(srcPath:string ,strictMode: boolean) {
  const file = fs.readFileSync(srcPath)
  // Generate the tsx code for the component
  const { code: tsxCode } = sv2tsx(file.toString('utf-8') ,{
    filename: srcPath
    // Assume true.
    // May need to parse it ourselves instead of using svelte2tsx
    // Since they do not look at lang tag
    // and lang can be different between script/module tags.
    ,isTsFile: true
    // If false, the usefulness of ts drops by 75%.
    ,strictMode
  })

  const shimmedCode = '/// <reference types="svelte2tsx/svelte-shims" />\n'
  + '/// <reference types="svelte2tsx/svelte-jsx" />\n'
  + `${tsxCode}`

  return shimmedCode
}

function shouldCreateVirtual(componentPath: string) {
  // Only create declarations if a conflicting typing file does not exist.
  let typedPath = `${componentPath}.ts`
  if (fs.existsSync(typedPath)) {
    throw new Error(`Ts file ${relPathJson(typedPath)} conflicts with ${relPathJson(componentPath)}.`)
  }

  typedPath = `${componentPath}.tsx`
  if (fs.existsSync(typedPath)) {
    throw new Error(`Tsx file ${relPathJson(typedPath)} conflicts with ${relPathJson(componentPath)}.`)
  }

  typedPath = `${componentPath}.d.ts`
  if (fs.existsSync(typedPath)) return false

  // No typings exists. Safe to generate!
  return true
}

interface RetType {
  extraFiles: Map<string ,TsxMappingVirtual>
  tsxMap: Map<string ,TsxMapping>
}

// Runs on multiple components at a time to reduce wasted cycles.
// shouldGenerateTypings = (filePath)=>filePath.endsWith('.svelte')
export function generateComponentDeclarations(
  componentPaths: string[]
  ,svelteExtensions: string[]
  ,srcDirs: string[]
  ,outDir: string
  ,strictMode: boolean
  ,shouldGenerateTypings: (filePath:string)=>boolean = () => false
): RetType {
  const requiresVirtualization = (filePath:string) => svelteExtensions.some((ext) => filePath.endsWith(ext)
  && shouldCreateVirtual(filePath))
  const genTsxPath = (filePath:string) => `${filePath}.tsx`
  const genTsxMapping = (filePath: string) => ({
    sourcePath: filePath
    ,...(requiresVirtualization(filePath)
      ? {
        code: generateTsx(filePath ,strictMode)
        ,virtualSourcePath: genTsxPath(filePath)
      } : {})
  } as TsxMapping)

  // Keep up with tsx->d.ts conversion paths
  const targetMap = new Map<string ,TsxMapping>()

  // Generate tsx files
  for (const sourcePath of componentPaths) {
    const newMapping = genTsxMapping(sourcePath)
    targetMap.set(newMapping.virtualSourcePath ?? newMapping.sourcePath ,newMapping)
  }

  // Generate d.ts files
  const extraFiles = compileTsDeclaration(targetMap ,{
    ...tsCompilerConfig
    ,declaration: true
    ,emitDeclarationOnly: true
    ,declarationDir: outDir
  } ,(filePath ,fileExists) => {
    // FIXME: This is contrived. Steal whatever code ts is using to loop fileExist instead
    // Only claim tsx files

    if (!filePath.endsWith('.tsx')) return

    const componentPath = filePath.replace(/\.tsx$/ ,'')
    // Only claim tsx files which refers to a file in the fs
    if (!fileExists(componentPath)) return

    // Only claim files we are interested in (like .svelte files)
    if (!shouldGenerateTypings(componentPath)) return

    if (!requiresVirtualization(componentPath)) return

    // Only claim files in src dir
    // if (!srcDirs.some((srcDir) => filePath.startsWith(srcDir))) return
    // console.log('Adding virtual' ,relativePath(filePath))

    // If we made it here, then we want to create a virtual file!
    const newMapping = genTsxMapping(componentPath)
    // auto generation may not be needed
    newMapping.autoGenerated = false
    targetMap.set(newMapping.virtualSourcePath ?? newMapping.sourcePath ,newMapping)
  })
  return {
    tsxMap: targetMap
    ,extraFiles
  }
}

function compileTsDeclaration(targetFiles: Map<string ,TsxMapping>
  ,options: ts.CompilerOptions
  ,autoVirtual: (filePath:string
    ,fileExist: ts.CompilerHost['fileExists'])=>void = () => {}) {
  // Create a Program with an in-memory emit
  const host = ts.createCompilerHost(options)
  const extraFiles = new Map<string ,TsxMappingVirtual>()
  host.writeFile = (fileName ,contents) => {
    extraFiles.set(fileName ,{
      code: contents
      ,virtualSourcePath: fileName
    })
  }
  const originalReadFile = host.readFile
  const originalFileExists = host.fileExists
  host.fileExists = (filePath) => {
    let foundTarget = false
    const isTargetCheck = () => {
      if (!foundTarget) {
        foundTarget = targetFiles.has(filePath)
      }
      return foundTarget
    }
    // Attempt to auto-create virtuals
    if (!isTargetCheck()) {
      autoVirtual(filePath ,(somePath) => originalFileExists.call(host ,somePath))
    }

    if (isTargetCheck() && originalFileExists.call(host ,filePath)) {
      const pathRe = /\.(?:ts|tsx|js|jsx|d\.ts)$/
      if (!pathRe.test(filePath)) {
        console.warn(`Read unexpected file path (${relPathJson(filePath)})`)
      }
    }
    return isTargetCheck() || originalFileExists.call(host ,filePath)
  }
  // eslint-disable-next-line arrow-body-style
  host.readFile = (filePath) => {
    // const asVirtual = files[filePath]?.code !== undefined
    // if (!filePath.includes('node_modules')) console.log(`Reading${asVirtual ? ' (virtual)' : ''}...`,relativePath(filePath))
    return targetFiles
      .get(filePath)
      ?.code ?? originalReadFile.call(host ,filePath)
  }
  // Prepare the contents for the d.ts files
  let runs = 1
  const maxAttempts = 5
  while (runs === 1 || (
    iti(targetFiles.values())
      .some((e) => e.autoGenerated === true)
    && runs <= maxAttempts
  )) {
    const remainingTargetFiles = runs === 1
      ? [...targetFiles.keys()]
      : iti(targetFiles.values())
        .filter((e) => e.autoGenerated === true)
        .map((e) => e.virtualSourcePath!)
        .toArray()

    console.log(`--- ${
      runs > 1 ? 'Re-' : ''
    }Running TS${
      runs === 1 ? '' : ` (attempt: ${runs})`
    } ---`)
    if (runs > 1) {
      console.log('Covering missed files'
        ,iti(targetFiles.values())
          .filter((e) => e.autoGenerated == true)
          .map((e) => relativePath(e.sourcePath))
          .toArray())
    }
    // Un-mark any auto generated files
    targetFiles.forEach((e) => {
      if (e.autoGenerated === true) e.autoGenerated = false
    })

    // Fix svelte tsx output to something typescript likes better
    // FIXME: There is a better way to loop this.
    // Maybe using .emit(fileName), or possible using languageServices.
    const programFix = ts.createProgram(remainingTargetFiles ,options ,host)
    const checker = programFix.getTypeChecker()
    const sourceFiles = programFix.getSourceFiles()
    for (const sourceFile of sourceFiles) {
      const targetFile = iti(targetFiles.values())
        .find((e) => e.virtualSourcePath === sourceFile.fileName)
      if (targetFile === undefined) continue
      ts.forEachChild(sourceFile ,(node) => {
        if (ts.isClassDeclaration(node)
        && node.modifiers?.some((e) => e.kind === ts.SyntaxKind.ExportKeyword) === true
        && node.modifiers?.some((e) => e.kind === ts.SyntaxKind.DefaultKeyword) === true
        ) {
          const someType = node.heritageClauses?.[0].types[0]
          if (
            someType !== undefined
            && someType.kind === ts.SyntaxKind.ExpressionWithTypeArguments
          ) {
            const componentType = checker.getTypeAtLocation(someType)
            const typeString = checker.typeToString(componentType)
            const oldCode = targetFile.code!
            targetFile.code = oldCode.slice(0 ,someType.pos + 1)
            + typeString
            + oldCode.slice(someType.end)
          }
        }
      })
    }
    // Emit files
    const programEmit = ts.createProgram(remainingTargetFiles ,options ,host)
    programEmit.emit()

    // Increment run counter
    runs++
  }
  return extraFiles
}
/*
function visit(node: ts.Node) {
  // Only consider exported nodes
  if (!node) {
    return
  }

  if (ts.isClassDeclaration(node) && node.name) {
    // This is a top level class, get its symbol
    const symbol = checker.getSymbolAtLocation(node.name)
    if (symbol) {
      output.push(serializeClass(symbol))
    }
    // No need to walk any further, class expressions/inner declarations
    // cannot be exported
  }
  else if (ts.isModuleDeclaration(node)) {
    // This is a namespace, visit its children
    ts.forEachChild(node ,visit)
  }
}
*/
